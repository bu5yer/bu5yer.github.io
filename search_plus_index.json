{"./":{"url":"./","title":"前言","keywords":"","body":"先在my_docs里面写文件,然后去SUMMARY.MD里面修改目录映射，最后运行start.sh Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-03 10:23:17 "},"my_docs/0x01_CTF/":{"url":"my_docs/0x01_CTF/","title":"0x01 CTF记录","keywords":"","body":"CTF文档 这一部分主要记录我在做CTF题中碰到的有意义的题目以及一些个人的经验总结。 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-16 18:20:02 "},"my_docs/0x01_CTF/web/":{"url":"my_docs/0x01_CTF/web/","title":"web相关","keywords":"","body":"web部分介绍 本部分主要介绍我遇到的一些有意义的web相关的CTF题。 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-16 18:21:25 "},"my_docs/0x01_CTF/web/bugku_sql0x1.html":{"url":"my_docs/0x01_CTF/web/bugku_sql0x1.html","title":"bugku sql0x1","keywords":"","body":"bugku中sql 0x1题目的记录 本题主要考察了sql注入的绕过和基本的源码审计能力。 1. 查看前端源码 可以从源码中看到提示信息，即进入/?pls_help 2. 查看源码 访问提示路径可得源码如下： \", \"query(\"SELECT * FROM users WHERE username='$user'\"); if ($result === false) die(\"pls dont break me\"); else $result = $result->fetchArray(); if ($result) { $split = explode('$', $result[\"password\"]); $password_hash = $split[0]; $salt = $split[1]; if ($password_hash === hash(\"sha256\", $pass.$salt)) $logged_in = true; else $err = \"Wrong password\"; } else $err = \"No such user\"; } ?> Hack.INI 9th - SQLi Welcome back admin! Have a flag: Login get some help --> 从代码中可以看出代码检测了user变量中的引号等敏感字符，接着在数据库中查找密码进行比对，如果正确就会输出flag。 3. 构造PoC 进一步分析源码，可以看出敏感字符检测中需要引号和空格同时存在才能被检出，因此可以考虑用/**/来代替空格，进而进行绕过。此外，可以查询一个不存在的user，联合上union select来查出我们给定的密码，进而完成登陆。 下面我们使用在线网站生成密码为test，盐值为123的sha256哈希值ecd71870d1963316a97e3ac3408c9835ad8cf0f3c1bc703527c30265534f75ae，接着构造如下poc即可： 用户名为test01'/**/union/**/select/**/1,'ecd71870d1963316a97e3ac3408c9835ad8cf0f3c1bc703527c30265534f75ae$123，密码为test。 4. 思考与扩展 空格绕过方式有哪些？ 怎么样才是正确的登陆逻辑？ 可以考虑将用户名和密码一起传进去查询 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-17 14:00:07 "},"my_docs/0x01_CTF/web/bugku_nextGen2.html":{"url":"my_docs/0x01_CTF/web/bugku_nextGen2.html","title":"bugku nextGen2","keywords":"","body":"bugku 中的nextGen2记录 本题考查了file协议的原理和绕过 1. 发现入口 通过点击可以发现request的service参数可以发送一个url，考虑使用file协议读取本地文件 2. 尝试攻击 修改service值为file:///flag.txt，发现返回失败。 3. 进行绕过 file协议一般可以使用下面几种格式： file:/// file://127.0.0.1/ file://localhost/ file://127.0.1/ file://127.1/ file://2130706433/ 4. 思考 问题的本质是127.0.0.1的其他表示方法，有没有其他方案呢？ 八进制表示017700000001 十六进制表示0x7F000001/0x7f000001 注意，这两个方案在file中并不生效，但是可以在其他地方进行尝试 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-17 17:01:59 "},"my_docs/0x01_CTF/web/bugku_Whois.html":{"url":"my_docs/0x01_CTF/web/bugku_Whois.html","title":"bugku Whois","keywords":"","body":"Bugku中Whois的记录 本题主要考察linux中的命令截断 1. 查看源码 在网页源码中发现query.php，访问可以发现如下源码： Whois 2. PoC构造 从上面的源码中可以发现，可以通过构造host和query参数来实现命令执行的效果。问题的关键在于whois命令的截断，这里可以考虑使用换行。 因此可以构造如下PoC: /query.php?host=whois.verisign-grs.com%0a&query=ls 3. 思考 其他的命令截断方案 可以考虑使用管道 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-17 17:39:49 "},"my_docs/0x01_CTF/experience/":{"url":"my_docs/0x01_CTF/experience/","title":"个人经验","keywords":"","body":"经验 本部分记录一些CTF相关的经验 Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-16 18:25:37 "},"my_docs/test.html":{"url":"my_docs/test.html","title":"0x02 渗透测试","keywords":"","body":"fhsdfhdsj Copyright © bu5yer 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-07-14 11:43:22 "}}